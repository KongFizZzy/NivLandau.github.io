import numpy as np
import modern_robotics as mr
def Puppet(thetalist, dthetalist, g, Mlist, Slist, Glist, t, dt,damping, stiffness, springPos, re
stLength):
 """
 :param thetalist: n-vector of initial joint angles (rad)
 :param dethatlist: n-vector of initial joint rates (rad/s)
 :param g: 3-vector representing gravity (m/s^2)
 :param Mlist: Configurations of the link frames relative to eachother in the home frame
 :param Slist: Screw axes relative to the space frame of the robot in home configuration
 :param Glist: spatial inertia matrices of the links (kg and kg-m^2)
 :param t: simulation time
 :param dt: timestep
 :param damping: scalar viscous damping at each joint (Nms/rad)
 :param stiffness: stiffness of spring (N/m)
 :param springPos: 3-
vector indicating the location of the end of the spring that is not attached
 to the robot, relative to the s frame. (m)
 :param restLength: scalar indicating length of spring at rest (m)
 :return thetamat: Nxn matric where row i is the set of joints after simulation step i-1
 :return dthetamat: same as thetamat but with joint rates (Nxn)
 """
 
 thetamat = np.array([thetalist]) #initializing output matrices
 dthetamat = np.array([dthetalist])
 
 for N in range(500):
 Msb = np.dot(np.dot(np.dot(M01,M12), np.dot(M23,M34)), np.dot(M56,M67))                  #Multiplying Mlist to get Msb
 Tsb = mr.FKinSpace(Msb, Slist, thetalist)
 pb = np.dot(mr.TransInv(Tsb), np.append(springPos,[1]))
 distance = np.sqrt(((0-springPos[0])^2 + (0-springPos[1])^2 + (0-springPos[2])^2 ))
 ftip = np.dot(-(stiffness * (distance - restLength)), springPos)                         #hooke's law to calculate Ftip:1X3
 ftip = np.append([0,0,0],ftip)
 taulist = (-damping * dthetalist) 
 ddthetalist = mr.ForwardDynamics(thetalist, dthetalist, taulist, g, ftip, Mlist, Glist, Slist)
 thetalistNext, dthetalistNext = mr.EulerStep(thetalist, dthetalist, ddthetalist, dt) 
 
 thetalistNext = thetalistNext % (2 * np.pi) #setting bounds for
theta values
 #between 0 and 2*pi
 thetamat = np.append(thetamat,[thetalistNext],axis = 0) #adding next step r
esults to
 dthetamat = np.append(dthetamat,[dthetalistNext],axis = 0) #output matrices
 thetalist = thetalistNext 
 dthetalist = dthetalistNext
 f = open("output.csv","w")
 for i in range(len(thetamat)):
 output = "%10.6f, %10.6f, %10.6f, %10.6f,%10.6f,%10.6f \n" \
 % (thetamat[i,0], thetamat[i,1], thetamat[i,2], thetamat[i,3], thetamat[i,4], thetamat[i,5
])
 f.write(output)
 f.close()

#Showing arm swinging at different timesteps: .01 and .006
M01 = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0.089159], [0, 0, 0, 1]]
M12 = [[0, 0, 1, 0.28], [0, 1, 0, 0.13585], [-1, 0, 0, 0], [0, 0, 0, 1]]
M23 = [[1, 0, 0, 0], [0, 1, 0, -0.1197], [0, 0, 1, 0.395], [0, 0, 0, 1]]
M34 = [[0, 0, 1, 0], [0, 1, 0, 0], [-1, 0, 0, 0.14225], [0, 0, 0, 1]]
M45 = [[1, 0, 0, 0], [0, 1, 0, 0.093], [0, 0, 1, 0], [0, 0, 0, 1]]
M56 = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0.09465], [0, 0, 0, 1]]
M67 = [[1, 0, 0, 0], [0, 0, 1, 0.0823], [0, -1, 0, 0], [0, 0, 0, 1]]
G1 = np.diag([0.010267495893, 0.010267495893, 0.00666, 3.7, 3.7, 3.7])
G2 = np.diag([0.22689067591, 0.22689067591, 0.0151074, 8.393, 8.393, 8.393])
G3 = np.diag([0.049443313556, 0.049443313556, 0.004095, 2.275, 2.275, 2.275])
G4 = np.diag([0.111172755531, 0.111172755531, 0.21942, 1.219, 1.219, 1.219])
G5 = np.diag([0.111172755531, 0.111172755531, 0.21942, 1.219, 1.219, 1.219])
G6 = np.diag([0.0171364731454, 0.0171364731454, 0.033822, 0.1879, 0.1879, 0.1879])
Glist = [G1, G2, G3, G4, G5, G6]
Mlist = [M01, M12, M23, M34, M45, M56, M67]
Slist = [[0, 0, 0, 0, 0, 0],
 [0, 1, 1, 1, 0, 1],
 [1, 0, 0, 0, -1, 0],
 [0, -0.089159, -0.089159, -0.089159, -0.10915, 0.005491],
 [0, 0, 0, 0, 0.81725, 0],
 [0, 0, 0.425, 0.81725, 0, 0.81725]]
t = 5
dt = 0.01 #.01 for coarse dt and .006 for smooth dt
g = np.array([0,0,-9.81])
thetalist = np.array([0,0,0,0,0,0])
dthetalist = np.array([0,0,0,0,0,0])
damping = 0
stiffness = 0
restLength = 0
springPos = np.array([0,0,0])
T = Puppet(thetalist, dthetalist, g, Mlist, Slist, Glist ,t, dt, damping, stiffness, springPos, r
estLength)

#PART 2: Robotics arm under positive damping

#Defining Transformation Matrices
M01 = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0.089159], [0, 0, 0, 1]]
M12 = [[0, 0, 1, 0.28], [0, 1, 0, 0.13585], [-1, 0, 0, 0], [0, 0, 0, 1]]
M23 = [[1, 0, 0, 0], [0, 1, 0, -0.1197], [0, 0, 1, 0.395], [0, 0, 0, 1]]
M34 = [[0, 0, 1, 0], [0, 1, 0, 0], [-1, 0, 0, 0.14225], [0, 0, 0, 1]]
M45 = [[1, 0, 0, 0], [0, 1, 0, 0.093], [0, 0, 1, 0], [0, 0, 0, 1]]
M56 = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0.09465], [0, 0, 0, 1]]
M67 = [[1, 0, 0, 0], [0, 0, 1, 0.0823], [0, -1, 0, 0], [0, 0, 0, 1]]
G1 = np.diag([0.010267495893, 0.010267495893, 0.00666, 3.7, 3.7, 3.7])
G2 = np.diag([0.22689067591, 0.22689067591, 0.0151074, 8.393, 8.393, 8.393])
G3 = np.diag([0.049443313556, 0.049443313556, 0.004095, 2.275, 2.275, 2.275])
G4 = np.diag([0.111172755531, 0.111172755531, 0.21942, 1.219, 1.219, 1.219])
G5 = np.diag([0.111172755531, 0.111172755531, 0.21942, 1.219, 1.219, 1.219])
G6 = np.diag([0.0171364731454, 0.0171364731454, 0.033822, 0.1879, 0.1879, 0.1879])
Glist = [G1, G2, G3, G4, G5, G6]
Mlist = [M01, M12, M23, M34, M45, M56, M67]
Slist = [[0, 0, 0, 0, 0, 0],
 [0, 1, 1, 1, 0, 1],
 [1, 0, 0, 0, -1, 0],
 [0, -0.089159, -0.089159, -0.089159, -0.10915, 0.005491],
 [0, 0, 0, 0, 0.81725, 0],
 [0, 0, 0.425, 0.81725, 0, 0.81725]]
t = 5
dt = 0.01 
g = np.array([0,0,-9.81])
thetalist = np.array([0,0,0,0,0,0])
dthetalist = np.array([0,0,0,0,0,0])
damping = -.01 # -.01 for negative and 2.4 for positive
stiffness = 0
restLength = 0
springPos = np.array([0,0,1])
T = Puppet(thetalist, dthetalist, g, Mlist, Slist, Glist ,t, dt, damping, stiffness, springPos, r
estLength
