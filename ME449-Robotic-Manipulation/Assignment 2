import modern_robotics as mr
import numpy as np
import matplotlib.pyplot as plt

def IKinBodyIterates(Blist, M, T, thetalist0, eomg, ev):
    """Computes inverse kinematics in the body frame for an open chain robot
    :param Blist: The joint screw axes in the end-effector frame when the
                  manipulator is at the home position, in the format of a
                  matrix with axes as the columns
    :param M: The home configuration of the end-effector
    :param T: The desired end-effector configuration Tsd
    :param thetalist0: An initial guess of joint angles that are close to
                       satisfying Tsd
    :param eomg: A small positive tolerance on the end-effector orientation
                 error. The returned joint angles must give an end-effector
                 orientation error less than eomg
    :param ev: A small positive tolerance on the end-effector linear position
               error. The returned joint angles must give an end-effector
               position error less than ev
    :return thetalist: Joint angles that achieve T within the specified
                       tolerances,
    :return success: A logical value where TRUE means that the function found
                     a solution and FALSE means that it ran through the set
                     number of maximum iterations without finding a solution
                     within the tolerances eomg and ev.
    Uses an iterative Newton-Raphson root-finding method.
    The maximum number of iterations before the algorithm is terminated has
    been hardcoded in as a variable called maxiterations. It is set to 20 at
    the start of the function, but can be changed if needed.
    """
    thetalist = np.array(thetalist0).copy()
    i = 0
    maxiterations = 20
    Vb = mr.se3ToVec(mr.MatrixLog6(np.dot(mr.TransInv(mr.FKinBody(M, Blist, \
                                                      thetalist)), T)))
    err = np.linalg.norm([Vb[0], Vb[1], Vb[2]]) > eomg \
          or np.linalg.norm([Vb[3], Vb[4], Vb[5]]) > ev

    jtm = np.array([thetalist0])                        #defining joint-theta matrix
    e_omg0 = np.linalg.norm([Vb[0], Vb[1], Vb[2]])      #defining initial angular error
    e_v0 = np.linalg.norm([Vb[3], Vb[4], Vb[5]])        #defining initial linear error
    err_omg = np.array([e_omg0])                        #Initializing angular error array
    err_v = np.array([e_v0])                            #Initializing linear error array
    itm = np.array([0])                                 #Initializing iteration array

    print("Iteration 0 (intial guess):\n\n")
    print("Joint Vector:")
    print(thetalist)
    
    print("\nSE(3) End-Effector Config:")
    print(mr.VecTose3(thetalist0))
    print("\nError Twist V_b: \n")
    print(Vb)
    print("\nangular error magnitude ||omega_b||:", \
          format((np.linalg.norm([Vb[0], Vb[1], Vb[2]])), ".3f" ))
    print("linear error magnitude ||v_b||:",\
          format((np.linalg.norm([Vb[3], Vb[4], Vb[5]])), ".3f" ))
    print("\n")

    while err and i < maxiterations:
        thetalist = thetalist \
                    + np.dot(np.linalg.pinv(mr.JacobianBody(Blist, \
                                                         thetalist)), Vb)
        Vb \
        = mr.se3ToVec(mr.MatrixLog6(np.dot(mr.TransInv(mr.FKinBody(M, Blist, \
                                                       thetalist)), T)))
        err = np.linalg.norm([Vb[0], Vb[1], Vb[2]]) > eomg \
              or np.linalg.norm([Vb[3], Vb[4], Vb[5]]) > ev

        i = i + 1   
        np.set_printoptions(precision=3)                 #Formats arrays to print up to 3 decimals
        jtm = np.append(jtm,[thetalist],axis=0)          #Appending joint vector for current i
        e_e = mr.VecTose3(thetalist)                     #Finding Tsb using current thetalist for i

        e_omg = np.linalg.norm([Vb[0], Vb[1], Vb[2]])    #Setting angular error mag. for current i
        e_v = np.linalg.norm([Vb[3], Vb[4], Vb[5]])      #Setting linear error mag. for current i
        err_omg = np.append(err_omg, e_omg)              #Appending errors to respective arrays
        err_v = np.append(err_v, e_v) 
        itm = np.append(itm, i)                          #Appending i to iteration array


        print("Iteration", i)
        print("\n\nJoint Vector:")
        print(thetalist)
        print("\nSE(3) End-Effector Config:")
        print(e_e)
        print("\nError Twist V_b: \n")
        print(Vb)
        print("\nangular error magnitude ||omega_b||:", \
          format(e_omg, ".3f" ))
        print("linear error magnitude ||v_b||:",\
          format(e_v, ".3f" ))
        print("\n")
    
    #Set up for CSV file export
    print(jtm)
    print('\n')
    
    f = open("output.csv","w")
    for i in range(len(jtm)):
      output = "%10.6f, %10.6f, %10.6f, %10.6f,%10.6f,%10.6f \n" \
       % (jtm[i,0], jtm[i,1], jtm[i,2], jtm[i,3], jtm[i,4], jtm[i,5])
      f.write(output)
    f.close()

    #Plotting Linear Error as a function of iterations
    #plt.plot(itm, err_v)
    #plt.xlabel('(Iterations (i)')
    #plt.ylabel('Magnitude of Linear Error')

    #Plotting Angular Error as a function of iterations
    #plt.plot(itm, err_omg)
    #plt.xlabel('Iterations (i)')
    #plt.ylabel('Magnitude of Angular Error')

    return (thetalist, not err)



#
#Input of given test values from the textbook and calling of function
#

Blist = np.array([[0,1,0,1.91,0,8.17],[0,0,1,.95,-8.17,0],[0,0,1,.95,-3.92,0],\
                  [0,0,1,.95,0,0],[0,-1,0,-.82,0,0],[0,0,1,0,0,0]])
M = np.array([[-1,0,0,8.17],[0,0,1,1.91],[0,1,0,-.006],[0,0,0,1]])  #in meters
T = np.array([[0,0,-1,.25],[1,0,0,-.15],[0,-1,0,.1],[0,0,0,1]])
eomg = .001
ev = .0001
thetalist0 = np.array([1.977,-1.288,-1.686,-3.22,1.251,0])

IKinBodyIterates(Blist, M, T, thetalist0, eomg, ev)
